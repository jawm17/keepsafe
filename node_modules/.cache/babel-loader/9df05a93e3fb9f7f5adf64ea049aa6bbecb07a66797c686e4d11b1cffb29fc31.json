{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError } from '../../errors/abi.js';\nimport { checksumAddress } from '../address/getAddress.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBigInt, hexToBool, hexToNumber, hexToString } from '../encoding/fromHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n  if (data === '0x' && params.length > 0) throw new AbiDecodingZeroDataError();\n  if (size(data) && size(data) < 32) throw new AbiDecodingDataSizeTooSmallError({\n    data,\n    params: params,\n    size: size(data)\n  });\n  return decodeParams({\n    data,\n    params: params\n  });\n}\nfunction decodeParams({\n  data,\n  params\n}) {\n  const decodedValues = [];\n  let position = 0;\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data)) throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params,\n      size: size(data)\n    });\n    const param = params[i];\n    const {\n      consumed,\n      value\n    } = decodeParam({\n      data,\n      param,\n      position\n    });\n    decodedValues.push(value);\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed;\n  }\n  return decodedValues;\n}\nfunction decodeParam({\n  data,\n  param,\n  position\n}) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(data, {\n      length,\n      param: {\n        ...param,\n        type: type\n      },\n      position\n    });\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, {\n      param: param,\n      position\n    });\n  }\n  if (param.type === 'string') {\n    return decodeString(data, {\n      position\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, {\n      param,\n      position\n    });\n  }\n  const value = slice(data, position, position + 32, {\n    strict: true\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, {\n      param\n    });\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value);\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\n////////////////////////////////////////////////////////////////////\nfunction decodeAddress(value) {\n  return {\n    consumed: 32,\n    value: checksumAddress(slice(value, -20))\n  };\n}\nfunction decodeArray(data, {\n  param,\n  length,\n  position\n}) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    // Get the length of the array from the offset.\n    const length = hexToNumber(slice(data, offset, offset + 32, {\n      strict: true\n    }));\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type);\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0];\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(slice(data, position, position + 32, {\n        strict: true\n      }));\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value.push(decodedChild.value);\n  }\n  return {\n    value,\n    consumed\n  };\n}\nfunction decodeBool(value) {\n  return {\n    consumed: 32,\n    value: hexToBool(value)\n  };\n}\nfunction decodeBytes(data, {\n  param,\n  position\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    const length = hexToNumber(slice(data, offset, offset + 32, {\n      strict: true\n    }));\n    // If there is no length, we have zero data.\n    if (length === 0) return {\n      consumed: 32,\n      value: '0x'\n    };\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true\n    });\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true\n  });\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeNumber(value, {\n  param\n}) {\n  const signed = param.type.startsWith('int');\n  const size = parseInt(param.type.split('int')[1] || '256');\n  return {\n    consumed: 32,\n    value: size > 48 ? hexToBigInt(value, {\n      signed\n    }) : hexToNumber(value, {\n      signed\n    })\n  };\n}\nfunction decodeString(data, {\n  position\n}) {\n  const offset = hexToNumber(slice(data, position, position + 32, {\n    strict: true\n  }));\n  const length = hexToNumber(slice(data, offset, offset + 32, {\n    strict: true\n  }));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return {\n    consumed: 32,\n    value: ''\n  };\n  const value = hexToString(trim(slice(data, offset + 32, offset + 32 + length, {\n    strict: true\n  })));\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeTuple(data, {\n  param,\n  position\n}) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value[hasUnnamedChild ? i : component?.name] = decodedChild.value;\n    }\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value[hasUnnamedChild ? i : component?.name] = decodedChild.value;\n  }\n  return {\n    consumed,\n    value\n  };\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiDecodingZeroDataError","InvalidAbiDecodingTypeError","checksumAddress","size","slice","trim","hexToBigInt","hexToBool","hexToNumber","hexToString","getArrayComponents","decodeAbiParameters","params","data","length","decodeParams","decodedValues","position","i","param","consumed","value","decodeParam","push","arrayComponents","type","decodeArray","decodeTuple","decodeString","startsWith","decodeBytes","strict","decodeNumber","decodeAddress","decodeBool","docsPath","offset","decodedChild","hasDynamicChild","dynamicChild","_","split","parseInt","signed","hasUnnamedChild","components","some","name","component","endsWith"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/viem/utils/abi/decodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport { checksumAddress } from '../address/getAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { trim } from '../data/trim.js'\nimport {\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: TParams, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<const TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<const TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<const TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}