{"ast":null,"code":"import { markToTrack, getUntracked } from 'proxy-compare';\nconst isObject = x => typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */new WeakMap();\nconst refSet = /* @__PURE__ */new WeakSet();\nconst buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = x => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), shouldTrapDefineProperty = desc => desc.configurable && desc.enumerable && desc.writable, defaultHandlePromise = promise => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach(key => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const desc = {\n      value,\n      enumerable: true,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n    } else if (value instanceof Promise) {\n      delete desc.value;\n      desc.get = () => handlePromise(value);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(value);\n      desc.value = createSnapshot(target2, ensureVersion(), handlePromise);\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n}, proxyCache = /* @__PURE__ */new WeakMap(), versionHolder = [1, 1], proxyFunction = initialObject => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = prop => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = prop => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = listener => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const trapSet = (hasPrevValue, prevValue, prop, value, setValue) => {\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = getUntracked(value) || value;\n    }\n    let nextValue = value;\n    if (value instanceof Promise) {\n      value.then(v => {\n        value.status = \"fulfilled\";\n        value.value = v;\n        notifyUpdate([\"resolve\", [prop], v]);\n      }).catch(e => {\n        value.status = \"rejected\";\n        value.reason = e;\n        notifyUpdate([\"reject\", [prop], e]);\n      });\n    } else {\n      if (!proxyStateMap.has(value) && canProxy(value)) {\n        nextValue = proxyFunction(value);\n      }\n      const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n      if (childProxyState) {\n        addPropListener(prop, childProxyState);\n      }\n    }\n    setValue(nextValue);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n  };\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      trapSet(hasPrevValue, prevValue, prop, value, nextValue => {\n        Reflect.set(target, prop, nextValue, receiver);\n      });\n      return true;\n    },\n    defineProperty(target, prop, desc) {\n      if (shouldTrapDefineProperty(desc)) {\n        const prevDesc = Reflect.getOwnPropertyDescriptor(target, prop);\n        if (!prevDesc || shouldTrapDefineProperty(prevDesc)) {\n          trapSet(!!prevDesc && \"value\" in prevDesc, prevDesc == null ? void 0 : prevDesc.value, prop, desc.value, nextValue => {\n            Reflect.defineProperty(target, prop, {\n              ...desc,\n              value: nextValue\n            });\n          });\n          return true;\n        }\n      }\n      return Reflect.defineProperty(target, prop, desc);\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (\"value\" in desc) {\n      proxyObject[key] = initialObject[key];\n      delete desc.value;\n      delete desc.writable;\n    }\n    Object.defineProperty(baseObject, key, desc);\n  });\n  return proxyObject;\n}) => [\n// public functions\nproxyFunction,\n// shared state\nproxyStateMap, refSet,\n// internal things\nobjectIs, newProxy, canProxy, shouldTrapDefineProperty, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder];\nconst [defaultProxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return defaultProxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = op => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };","map":{"version":3,"names":["markToTrack","getUntracked","isObject","x","proxyStateMap","WeakMap","refSet","WeakSet","buildProxyFunction","objectIs","Object","is","newProxy","target","handler","Proxy","canProxy","has","Array","isArray","Symbol","iterator","Error","Number","Date","String","RegExp","ArrayBuffer","shouldTrapDefineProperty","desc","configurable","enumerable","writable","defaultHandlePromise","promise","status","value","reason","snapCache","createSnapshot","version","handlePromise","cache","get","snap","create","getPrototypeOf","set","Reflect","ownKeys","forEach","key","getOwnPropertyDescriptor","Promise","target2","ensureVersion","defineProperty","preventExtensions","proxyCache","versionHolder","proxyFunction","initialObject","found","listeners","Set","notifyUpdate","op","nextVersion","listener","checkVersion","nextCheckVersion","size","propProxyStates","propProxyState","propVersion","createPropListener","prop","newOp","Map","addPropListener","import","meta","env","MODE","remove","removePropListener","_a","entry","delete","call","addListener","add","prevRemove","removeListener","baseObject","trapSet","hasPrevValue","prevValue","setValue","nextValue","then","v","catch","e","childProxyState","deleteProperty","deleted","receiver","prevDesc","proxyObject","proxyState","defaultProxyFunction","proxy","getVersion","subscribe","callback","notifyInSync","console","warn","ops","isListenerActive","push","splice","resolve","snapshot","ref","obj","unstable_buildProxyFunction"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/valtio/esm/vanilla.mjs"],"sourcesContent":["import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), shouldTrapDefineProperty = (desc) => desc.configurable && desc.enumerable && desc.writable, defaultHandlePromise = (promise) => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const desc = {\n      value,\n      enumerable: true,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n    } else if (value instanceof Promise) {\n      delete desc.value;\n      desc.get = () => handlePromise(value);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshot(\n        target2,\n        ensureVersion(),\n        handlePromise\n      );\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const trapSet = (hasPrevValue, prevValue, prop, value, setValue) => {\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = getUntracked(value) || value;\n    }\n    let nextValue = value;\n    if (value instanceof Promise) {\n      value.then((v) => {\n        value.status = \"fulfilled\";\n        value.value = v;\n        notifyUpdate([\"resolve\", [prop], v]);\n      }).catch((e) => {\n        value.status = \"rejected\";\n        value.reason = e;\n        notifyUpdate([\"reject\", [prop], e]);\n      });\n    } else {\n      if (!proxyStateMap.has(value) && canProxy(value)) {\n        nextValue = proxyFunction(value);\n      }\n      const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n      if (childProxyState) {\n        addPropListener(prop, childProxyState);\n      }\n    }\n    setValue(nextValue);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n  };\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      trapSet(hasPrevValue, prevValue, prop, value, (nextValue) => {\n        Reflect.set(target, prop, nextValue, receiver);\n      });\n      return true;\n    },\n    defineProperty(target, prop, desc) {\n      if (shouldTrapDefineProperty(desc)) {\n        const prevDesc = Reflect.getOwnPropertyDescriptor(target, prop);\n        if (!prevDesc || shouldTrapDefineProperty(prevDesc)) {\n          trapSet(\n            !!prevDesc && \"value\" in prevDesc,\n            prevDesc == null ? void 0 : prevDesc.value,\n            prop,\n            desc.value,\n            (nextValue) => {\n              Reflect.defineProperty(target, prop, {\n                ...desc,\n                value: nextValue\n              });\n            }\n          );\n          return true;\n        }\n      }\n      return Reflect.defineProperty(target, prop, desc);\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [\n    baseObject,\n    ensureVersion,\n    createSnapshot,\n    addListener\n  ];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      initialObject,\n      key\n    );\n    if (\"value\" in desc) {\n      proxyObject[key] = initialObject[key];\n      delete desc.value;\n      delete desc.writable;\n    }\n    Object.defineProperty(baseObject, key, desc);\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  shouldTrapDefineProperty,\n  defaultHandlePromise,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nconst [defaultProxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return defaultProxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\n\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}