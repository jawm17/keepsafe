{"ast":null,"code":"import { universalSignatureValidatorAbi } from '../../constants/abis.js';\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js';\nimport { CallExecutionError } from '../../errors/contract.js';\nimport { isBytesEqual } from '../../utils/data/isBytesEqual.js';\nimport { encodeDeployData, isHex, toHex } from '../../utils/index.js';\nimport { call } from './call.js';\n/**\n * Verifies a message hash on chain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, {\n  address,\n  hash,\n  signature,\n  ...callRequest\n}) {\n  const signatureHex = isHex(signature) ? signature : toHex(signature);\n  try {\n    const {\n      data\n    } = await call(client, {\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, signatureHex],\n        bytecode: universalSignatureValidatorByteCode\n      }),\n      ...callRequest\n    });\n    return isBytesEqual(data ?? '0x0', '0x1');\n  } catch (error) {\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false;\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["universalSignatureValidatorAbi","universalSignatureValidatorByteCode","CallExecutionError","isBytesEqual","encodeDeployData","isHex","toHex","call","verifyHash","client","address","hash","signature","callRequest","signatureHex","data","abi","args","bytecode","error"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js'\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isBytesEqual } from '../../utils/data/isBytesEqual.js'\nimport { encodeDeployData, isHex, toHex } from '../../utils/index.js'\nimport { type CallParameters, call } from './call.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hex\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray\n}\n\nexport type VerifyHashReturnType = boolean\n\n/**\n * Verifies a message hash on chain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  { address, hash, signature, ...callRequest }: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const signatureHex = isHex(signature) ? signature : toHex(signature)\n\n  try {\n    const { data } = await call(client, {\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, signatureHex],\n        bytecode: universalSignatureValidatorByteCode,\n      }),\n      ...callRequest,\n    } as unknown as CallParameters)\n\n    return isBytesEqual(data ?? '0x0', '0x1')\n  } catch (error) {\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n"],"mappings":"AAIA,SAASA,8BAA8B,QAAQ,yBAAyB;AACxE,SAASC,mCAAmC,QAAQ,8BAA8B;AAClF,SAASC,kBAAkB,QAAQ,0BAA0B;AAG7D,SAASC,YAAY,QAAQ,kCAAkC;AAC/D,SAASC,gBAAgB,EAAEC,KAAK,EAAEC,KAAK,QAAQ,sBAAsB;AACrE,SAA8BC,IAAI,QAAQ,WAAW;AAgBrD;;;;;;;AAOA,OAAO,eAAeC,UAAUA,CAC9BC,MAAiC,EACjC;EAAEC,OAAO;EAAEC,IAAI;EAAEC,SAAS;EAAE,GAAGC;AAAW,CAAwB;EAElE,MAAMC,YAAY,GAAGT,KAAK,CAACO,SAAS,CAAC,GAAGA,SAAS,GAAGN,KAAK,CAACM,SAAS,CAAC;EAEpE,IAAI;IACF,MAAM;MAAEG;IAAI,CAAE,GAAG,MAAMR,IAAI,CAACE,MAAM,EAAE;MAClCM,IAAI,EAAEX,gBAAgB,CAAC;QACrBY,GAAG,EAAEhB,8BAA8B;QACnCiB,IAAI,EAAE,CAACP,OAAO,EAAEC,IAAI,EAAEG,YAAY,CAAC;QACnCI,QAAQ,EAAEjB;OACX,CAAC;MACF,GAAGY;KACyB,CAAC;IAE/B,OAAOV,YAAY,CAACY,IAAI,IAAI,KAAK,EAAE,KAAK,CAAC;GAC1C,CAAC,OAAOI,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYjB,kBAAkB,EAAE;MACvC;MACA;MACA;MACA,OAAO,KAAK;;IAGd,MAAMiB,KAAK;;AAEf"},"metadata":{},"sourceType":"module","externalDependencies":[]}