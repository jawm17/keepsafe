{"ast":null,"code":"import { call } from '../actions/public/call.js';\nimport '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nexport async function offchainLookup(client, {\n  blockNumber,\n  blockTag,\n  data,\n  to\n}) {\n  const {\n    args\n  } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = await ccipFetch({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([callbackSelector, encodeAbiParameters([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nexport async function ccipFetch({\n  data,\n  sender,\n  urls\n}) {\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    try {\n      const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n        body: JSON.stringify(body),\n        method\n      });\n      let result;\n      if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","map":{"version":3,"names":["call","OffchainLookupError","OffchainLookupResponseMalformedError","OffchainLookupSenderMismatchError","HttpRequestError","decodeErrorResult","encodeAbiParameters","isAddressEqual","concat","isHex","stringify","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","offchainLookup","client","blockNumber","blockTag","data","to","args","abi","sender","urls","callData","callbackSelector","extraData","result","ccipFetch","data_","err","cause","error","Error","i","length","url","method","includes","body","undefined","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","details","statusText","status","message"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}