{"ast":null,"code":"import { execTyped } from '../regex.js';\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\nexport function formatAbiParameter(abiParameter) {\n  let type = abiParameter.type;\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '(';\n    const length = abiParameter.components.length;\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i];\n      type += formatAbiParameter(component);\n      if (i < length - 1) type += ', ';\n    }\n    const result = execTyped(tupleRegex, abiParameter.type);\n    type += `)${result?.array ?? ''}`;\n    return formatAbiParameter({\n      ...abiParameter,\n      type\n    });\n  }\n  if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;\n  if (abiParameter.name) return `${type} ${abiParameter.name}`;\n  return type;\n}","map":{"version":3,"names":["execTyped","tupleRegex","formatAbiParameter","abiParameter","type","test","length","components","i","component","result","array","indexed","name"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/abitype/src/human-readable/formatAbiParameter.ts"],"sourcesContent":["import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param TAbiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  TAbiParameter extends AbiParameter | AbiEventParameter,\n> = TAbiParameter extends {\n  name?: infer Name extends string\n  type: `tuple${infer Array}`\n  components: infer Components extends readonly AbiParameter[]\n  indexed?: infer Indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [K in keyof Components]: FormatAbiParameter<\n              {\n                type: Components[K]['type']\n              } & (IsNarrowable<Components[K]['name'], string> extends true\n                ? { name: Components[K]['name'] }\n                : unknown) &\n                (Components[K] extends { components: readonly AbiParameter[] }\n                  ? { components: Components[K]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${Array}`\n      } & (IsNarrowable<Name, string> extends true ? { name: Name } : unknown) &\n        (IsNarrowable<Indexed, boolean> extends true\n          ? { indexed: Indexed }\n          : unknown)\n    >\n  : `${TAbiParameter['type']}${TAbiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${TAbiParameter['name'] extends infer Name extends string\n      ? Name extends ''\n        ? ''\n        : ` ${AssertName<Name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const TAbiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: TAbiParameter): FormatAbiParameter<TAbiParameter> {\n  type Result = FormatAbiParameter<TAbiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n"],"mappings":"AACA,SAASA,SAAS,QAAQ,aAAa;AAqDvC,MAAMC,UAAU,GAAG,+BAA+B;AAYlD,OAAM,SAAUC,kBAAkBA,CAEhCC,YAA2B;EAG3B,IAAIC,IAAI,GAAGD,YAAY,CAACC,IAAI;EAC5B,IAAIH,UAAU,CAACI,IAAI,CAACF,YAAY,CAACC,IAAI,CAAC,IAAI,YAAY,IAAID,YAAY,EAAE;IACtEC,IAAI,GAAG,GAAG;IACV,MAAME,MAAM,GAAGH,YAAY,CAACI,UAAU,CAACD,MAAgB;IACvD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAGN,YAAY,CAACI,UAAU,CAACC,CAAC,CAAE;MAC7CJ,IAAI,IAAIF,kBAAkB,CAACO,SAAS,CAAC;MACrC,IAAID,CAAC,GAAGF,MAAM,GAAG,CAAC,EAAEF,IAAI,IAAI,IAAI;;IAElC,MAAMM,MAAM,GAAGV,SAAS,CAAqBC,UAAU,EAAEE,YAAY,CAACC,IAAI,CAAC;IAC3EA,IAAI,IAAI,IAAIM,MAAM,EAAEC,KAAK,IAAI,EAAE,EAAE;IACjC,OAAOT,kBAAkB,CAAC;MACxB,GAAGC,YAAY;MACfC;KACD,CAAW;;EAGd,IAAI,SAAS,IAAID,YAAY,IAAIA,YAAY,CAACS,OAAO,EACnDR,IAAI,GAAG,GAAGA,IAAI,UAAU;EAE1B,IAAID,YAAY,CAACU,IAAI,EAAE,OAAO,GAAGT,IAAI,IAAID,YAAY,CAACU,IAAI,EAAY;EACtE,OAAOT,IAAc;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}