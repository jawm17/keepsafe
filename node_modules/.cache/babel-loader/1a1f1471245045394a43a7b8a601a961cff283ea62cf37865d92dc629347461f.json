{"ast":null,"code":"import { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);\n  if (typeof value === 'string') {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value, opts = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value, opts = {}) {\n  let hexString = '';\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]];\n  }\n  const hex = `0x${hexString}`;\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_, opts = {}) {\n  const {\n    signed,\n    size\n  } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`\n    });\n  }\n  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;\n  if (size) return pad(hex, {\n    size\n  });\n  return hex;\n}\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_, opts = {}) {\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}","map":{"version":3,"names":["IntegerOutOfRangeError","pad","assertSize","hexes","Array","from","length","_v","i","toString","padStart","toHex","value","opts","numberToHex","stringToHex","boolToHex","bytesToHex","hex","Number","size","hexString","dir","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","max","undefined","min","encoder","TextEncoder","encode"],"sources":["/Users/envyhose/Desktop/programs/keepsafe_repo/keepsafe/client/node_modules/viem/utils/encoding/toHex.ts"],"sourcesContent":["import { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let hexString = ''\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]]\n  }\n\n  const hex: Hex = `0x${hexString}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}